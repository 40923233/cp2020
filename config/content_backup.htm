<h1>首頁</h1>
<h1>HW1</h1>
<h2>cool down(冷卻)</h2>
<p><strong><a tabindex=""></a></strong></p>
<div class="section" id="N10666">
<div class="sectionContain"></div>
</div>
<div class="section" id="N106D6">The heat source in the computer circuit and its influence, and the method of cooling the CPU system.</div>
<div class="section"></div>
<div class="section">計算機電路裡的熱源及其影響，以及冷卻CPU.系統的方法。</div>
<div class="section"></div>
<div class="section"><strong></strong></div>
<div class="section"><span style="color: #cc99ff;"><strong>Heat source(熱源)</strong></span></div>
<div class="section"><strong></strong></div>
<p>When current flows in a computer circuit, it will generate heat when it encounters a resistance. The larger the current, the better the computer's computing performance to cope with the specific operations that require a lot of calculations, but more heat will come with it. Other heat-generating sources include optical drives, hard disks, power switches, etc. The power switches also generate a lot of heat when AC power is converted to DC power, so power supplies usually have their own dedicated cooling fan.</p>
<p>電流在計算機電路中流動時遇到電阻時就會產生熱能，越大的電流會讓計算機的運算效能變好以應付需要大量計算的特定操作但隨之而來的也會是更大的熱能。其他會產生熱能的有光盤驅動器、硬碟、電源交換器等等，其中電源交換器在交流電轉直流電也會產生大量熱能，所以電源供應器通常會有自己專屬的一顆散熱風扇。</p>
<p><span style="color: #cc99ff;"><strong>Thermal effect(熱效應)</strong></span></p>
<p>If the heat inside the computer is too high, the BIOS may reduce the CPU frequency to prevent overheating from damaging the internal electronic components. The hard disk drive, CPU, and GPU are all sensitive to temperature changes. Due to the expansion and contraction of equipment components, and the hard disk drive will cause irreparable damage due to temperature changes. This may cause read/write errors, or even complete failure of the disk drive.</p>
<p></p>
<p>如果計算機內部的熱量過高，則BIOS可能會降低CPU頻率避免過熱損傷內部電子元件，硬盤驅動器、CPU和GPU都對溫度變化敏感。由於設備組件的膨脹和收縮，且硬盤驅動器會因溫度變化而造成不可挽回的損害。這可能導致讀/寫錯誤，甚至導致磁盤驅動器完全故障。</p>
<p><span style="color: #cc99ff;"><strong>Reduce calories(減少熱量)</strong></span></p>
<p>Use heat sinks to draw heat away from sensitive components (such as CPU, GPU, North Bridge and South Bridge) through conduction. Use a fan to blow (suck) away the heat on the radiating fins, and then take the heat out of the case through the vents of the case.</p>
<p>使用散熱器通過傳導將熱量從敏感組件（例如CPU，GPU，北橋和南橋）吸走。用風扇將散熱鰭片上的熱量吹(吸)走，在經過機殼通風口將熱量帶出機殼。</p>
<p><span style="color: #cc99ff;"><strong>BIOS settings(BIOS設置)</strong></span></p>
<p>Most motherboards and BIOS have a word on the temperature monitoring of the host and its components. For the ultra-flat motherboard, the current, voltage, frequency, etc. can be customized to increase or decrease its computing power.</p>
<p>大多數主板和BIOS都有之詞對主辦及其組件的溫度監控。對於之詞超平的主板可以自訂義電流、電壓、頻率等，以增加或減少其運算能力。</p>
<p><img alt="" height="270" src="/images/overclock-from-bios-screen.png.rendition.intel.web.480.270.png" width="480"/></p>
<p><span style="color: #cc99ff;"><strong>Cooling method(冷卻方法)</strong></span></p>
<p>The active air consists of a fan and a cooling plate made of aluminum or copper. The fan blows air onto the cooling fins above the components. The heat dissipation fins increase the surface of the metal plate and increase the heat dissipation capacity. However, components that generate heat from active air cannot be cooled below room temperature because active cooling uses air from the room.</p>
<p>主動空氣由風扇和鋁或銅製成的冷卻板組成。風扇將空氣吹到組件上方的散熱鰭片上。散熱鰭片增加了金屬板的表面，增加散熱能力。但主動空氣產生熱量的組件無法冷卻到室溫以下，因為主動冷卻使用來自房間的空氣。<img alt="" height="469" src="/images/1522115539-2889232472.jpg" width="600"/></p>
<p><span style="color: #cc99ff;"><strong>Passive air cooling(被動風冷)</strong></span></p>
<p>The difference between passive air cooling is the size of the heat sink, the heat sink must be large enough, and it must also have enough space for natural air flow, and thus heat dissipation. In terms of power saving, passive air cooling is the most effective cooling method because it does not use any power source. The disadvantage of this method is that it is heavy, which increases the total weight and reduces the usable area inside the chassis.</p>
<p>被動空氣冷區別在於散熱器的大小，散熱片必須足夠大，並且還必須具有足夠的空間，以便自然的空氣流動，從而散熱。省電而言，被動式空氣冷卻是最有效的冷卻方式，因為它不用任何電源。這種方法的缺點是重量大，會增加總重量並減小機箱內部的可用面積。</p>
<p><span style="color: #cc99ff;"><strong>Liquid cooling(液體冷卻)</strong></span></p>
<p>Liquid cooling uses the basic principles of thermodynamics. Heat transfers from hotter objects to colder objects, transferring more heat than air, making liquid cooling very suitable for overclocking and high-performance computer applications, and liquid cooling is not affected by ambient temperature Influence, compared with active cooling, liquid cooling uses a quieter and smaller fan, but the main disadvantages of liquid cooling are complexity and cost. Water vapor and liquid leakage may damage the electronic components inside the computer.</p>
<p>液體冷卻利用了熱力學的基本原理，熱量從較熱的物體轉移到較冷的物體，比空氣傳遞更多的熱量，使液體冷卻非常適合超頻和高性能計算機應用，且液體冷卻不受環境溫度的影響，與主動冷卻相比，液體冷卻使用的風扇更安靜、更小，但液體冷卻的主要缺點是複雜性和成本。可能結水氣、漏液造成計算機內部電子元件的損傷。<img alt="" height="400" src="/images/01-18-600x400.jpg" width="600"/><strong><br/></strong></p>
<p><span style="color: #cc99ff;"><strong>Cooling installation and maintenance(冷卻安裝和維護)</strong></span></p>
<p>機箱風扇(Case fan)</p>
<p>The chassis fan is mainly used to exhaust the hot air in the case and replace it with fresh cold air. Usually the colder air is close to the ground, so most of them are designed to suck in the system from the bottom. Then, the hot air is discharged from the rear of the case near the CPU and the side of the case near the graphics processing unit.</p>
<p>機箱風扇主要用於排出機殼內的熱空氣替換成新鮮的冷空氣，通常較冷的空氣靠近地面，因此大多數都設計成從底部吸入系統。然後，熱空氣從CPU附近的機箱後部以及圖形處理單元附近的機箱側面排出。</p>
<p><span style="color: #cc99ff;"><strong>Liquid cooling: installation(液體冷卻：安裝)</strong></span></p>
<p>Turn off the computer and unplug the power plug-open the case-clean the CPU and water block-remove dust and debris-use thermal paste-install the heat sink-connect the heat sink to the water tank-make sure to reconnect the power supply-turn on the computer power-ensure the liquid The cooling system is operating normally-close the housing</p>
<p>關閉計算機電源並拔下電源插頭-打開機箱-清潔CPU和水塊-清除灰塵和碎屑-使用導熱膏-安裝散熱器-將散熱器連接到水箱-確保重新連接電源-打開計算機電源-確保液體冷卻系統正常運行-關閉外殼</p>
<h2>Network overview(網路概述)</h2>
<p>Various network relationships including local area networks, wide area networks, personal local area networks, and metropolitan area networks, such as client/server and peer-to-peer networks, and discuss the types of network resources.</p>
<p>各種網絡關係包括局域網、廣域網、個人局域網和城域網各種網絡關係，例如客戶端/服務器和對等網絡，並討論網絡資源類型。</p>
<p><span style="color: #cc99ff;"><strong>Geographically defined network(地理定義的網絡)</strong></span></p>
<p>The geographic location covered by the network. Starting from the area around a person, the area is called a personal area network (PAN). Next, expand out to the local area network (LAN), which contains the entire office floor or building. Moving outward again, we have a metropolitan area network, which is connected by multiple LANs to cover the entire city. Finally, there is a wide area network (WAN). The largest network defined by geographic location, it can spread all over the country or even the whole world.</p>
<p>網絡所覆蓋的地理位置。從一個人周圍的區域開始，將該區域稱為個人區域網絡（PAN）。接下來，向外擴展到局域網（LAN），該局域網包含整個辦公樓層或建築物。再次向外移動，我們有城域網，城域網通過多個LAN連接在一起而覆蓋了整個城市。最後，有了廣域網（WAN）。按地理位置定義的最大網絡，它可以遍及全國甚至遍及全球。<strong><br/></strong></p>
<p><img alt="" height="154" src="/images/下載.jpg" width="326"/></p>
<p><span style="color: #cc99ff;"><strong>Personal area network(個人區域網)</strong></span></p>
<p>The range is very small, only a few meters, and Bluetooth is one of the main content used to create PAN, although USB and infrared can also be used for these networks. The range of Bluetooth is between 1 meter and 100 meters, depending on the type of Bluetooth used.</p>
<p>範圍很小，只有幾米，藍牙是用於創建PAN的主要內容之一，儘管USB和紅外也可以用於這些網絡。藍牙的範圍在1米至100米之間，取決於使用的藍牙類別。</p>
<p><span style="color: #cc99ff;"><strong>Metropolitan Area Network(城域網)</strong></span></p>
<p>Think of it as MAN. Connect scattered locations throughout the city or county. This covers a larger geographic area than a local area network, but much smaller than a wide area network.</p>
<p><br/>將其作為MAN。連接整個城市或縣的分散位置。這比局域網覆蓋更大的地理區域，但是比廣域網覆蓋的區域小得多。</p>
<p><span style="color: #cc99ff;"><strong>Wan(廣域網)</strong></span></p>
<p>Connect remotely located network components together. This can be done through a virtual private network (VPN) on the Internet or using a dedicated leased line that actually connects the city pairs together. Once the two local area networks are connected, they become part of the larger WAN topology.</p>
<p>將地理位置遙遠的網絡組件連接在一起。可以通過Internet上的虛擬專用網絡（VPN）或使用將城市對實際連接在一起的專用租用線路來完成。兩個局域網一旦連接，它們便成為更大的廣域網拓撲的一部分。</p>
<h2>Topology-defined network(拓撲定義的網絡)</h2>
<p></p>
<p><span style="color: #cc99ff;"><strong>Bus topology(總線拓撲)</strong></span></p>
<p>Usually a cable is used to pass through the area that needs network connection, and every device that wants to connect to the network is connected through the cable. The device uses a T-connector or vampire tap to insert the cable. Although the bus topology is an older technology that is no longer used physically, it can still be implemented as a logic in some cases.</p>
<p><br/>通常使用一根電纜穿過需要網絡連接的區域，每個希望連接到網絡的設備都通過該電纜連接。設備使用T型連接器或吸血鬼抽頭插入電纜。儘管總線拓撲是一項較舊的技術，在物理上已不再使用，但在某些情況下仍可以作為邏輯實現。</p>
<p><br/><span style="color: #cc99ff;"><strong>Ring topology(環形拓撲)</strong></span></p>
<p>Using cables running in a loop loop, each device is connected to the loop. Data travels in a single direction on the ring. The most common is used with backbone fiber optic networks. Fiber Distributed Data Interface (FDDI) is a set of standards used to transmit data on fiber optic lines in LANs. Each device waits for it to communicate on the token ring by passing tokens around the token ring. A ring topology network is also called a token ring network. Because there are two counter-rotating rings, FDDI tends to provide more redundancy than standard bus topologies. However, in most LANs, bus topology and ring topology are quickly replaced by star topology.</p>
<p>使用在環形迴路中運行的電纜，每個設備都連接到環形。數據在環上沿單個方向傳播。最常見的是與骨幹光纖網絡一起使用。光纖分佈式數據接口（FDDI）是用於在LAN中的光纖線上傳輸數據的一組標準。每個設備都通過在令牌環周圍傳遞令牌來等待其在令牌環上進行通信。環形拓撲網絡也稱為令牌環網絡。由於有兩個反向旋轉的環，因此FDDI傾向於提供比標準總線拓撲更多的冗餘。但是，在大多數LAN中，總線拓撲和環形拓撲都很快被星形拓撲取代。</p>
<p><span style="color: #cc99ff;"><strong>Star topology(星型拓撲)</strong></span></p>
<p>The star topology is the most common topology. Almost all LANs use a star topology. All devices in the star topology are connected to one point. A single connection point can be a hub or switch. In most modern networks, the single connection point will be a switch. Star topologies are the main physical topologies today, although they are not always used as logical topologies. Fiber optic connections can also be used for high-speed or high-security networks. The disadvantage of the star topology is that it will cause a single point of failure. If a central device (such as a switch) fails, the entire network will also fail. Different from the bus and ring network varieties, the star topology has the advantages of reducing costs and being easy to expand.</p>
<p>星形拓撲是最常見的拓撲。幾乎所有局域網都使用星型拓撲。星型拓撲的所有設備都連接到一個點。單個連接點可以是集線器或交換機。在大多數現代網絡中，單個連接點將是一個交換機。星形拓撲是當今主要的物理拓撲，儘管它們並不總是用作邏輯拓撲。光纖連接也可以用於高速或高安全性網絡。星形拓撲的缺點是會造成單點故障。如果中央設備（如交換機）發生故障，整個網絡也會失敗。與總線和環形網絡品種不同，星形拓撲結構具有減少費用並易於擴展的優勢。</p>
<p><span style="color: #cc99ff;"><strong>Full mesh topology(全網狀拓撲)</strong></span></p>
<p>In order to solve the redundancy problem, a full mesh topology was created. So far, this topology is the most redundant and expensive topology because every node or workstation in the network is directly connected to every other node, but it is very expensive to maintain and operate.</p>
<p>為了解決冗餘問題，創建了全網狀拓撲。到目前為止，此拓撲是最冗餘，最昂貴的拓撲，因為網絡中的每個節點或工作站都直接連接到每個其他節點，但維護和操作非常昂貴。</p>
<div class="tlid-input input has-transliteration">
<div class="source-wrap">
<div class="input-full-height-wrapper tlid-input-full-height-wrapper">
<div class="source-input">
<div class="tlid-source-transliteration-container source-transliteration-container transliteration-container">
<div class="tlid-transliteration-content transliteration-content full"></div>
</div>
</div>
</div>
</div>
</div>
<div class="tlid-results-container results-container">
<div class="tlid-result result-dict-wrapper">
<div class="result tlid-copy-target">
<div class="text-wrap tlid-copy-target"></div>
</div>
</div>
</div>
<p><span style="color: #cc99ff;"><strong>Partial mesh topology(部分網格拓撲)</strong></span></p>
<p>In order to solve the cost problem created by the full mesh topology, a partial mesh topology was created. Part of the mesh topology is actually a hybrid full mesh topology. Provides redundancy and optimal routing between certain sites, while avoiding the overhead of connecting each site.</p>
<p>為了解決由全網格拓撲創建的成本問題，創建了部分網格拓撲。部分網狀拓撲實際上是混合全網狀拓撲。提供了某些站點之間的冗餘和最佳路由，同時避免了連接每個站點的開銷。</p>
<h2>Network hardware(網路硬件)</h2>
<p>網絡設備根據其用途而有所不同。各種設備，例如集線器，交換機，路由器，網橋，網絡適配器和媒體。</p>
<p>Network equipment varies according to its purpose. Various devices such as hubs, switches, routers, bridges, network adapters and media.</p>
<p><strong><span style="color: #cc99ff;">hub(樞紐)</span></strong></p>
<p>A hub is one of the simplest network devices. It connects multiple network devices and workstations to each other to form a network. It works by receiving a signal in one port and rebroadcasting the signal to all other ports. Hubs can be divided into two types: active or passive. The active hub repeats the received signal on all its ports and amplifies the signal to its maximum strength. Passive hubs only repeat the signal without adding any amplification. Hubs are an older technology that can be used to easily increase the number of available ports, but cause too many network errors and conflicts. There are newer variants of hubs, called smart hubs.</p>
<p>The three basic types of Ethernet hubs are as follows:</p>
<p>Passive hub-repeat signal without amplification<br/>Active Hub – Repeatedly amplify the signal<br/>Smart Hub-Active hub with enhanced functions (for example: SNMP)</p>
<p>There is no inherent security designed inside the hub, but all information received from one port is rebroadcasted to another port. Essentially, the hub only relies on the connected workstation to "listen" to information on its port (if the information is specifically for that workstation). When the information is not sent to it, the workstation should just ignore the data.</p>
<p>集線器是最簡單的網絡設備之一，將多個網絡設備和工作站相互連接，形成一個網絡，通過在一個端口中接收信號並將該信號重新廣播到其所有其他端口來工作。集線器可以分為主動或被動兩種。活動集線器會在其所有端口上重複接收到的信號，並將該信號放大到最大強度。無源集線器僅重複信號不增加任何放大。集線器是一種較舊的技術，可用於輕鬆增加可用端口的數量，但導致過多的網絡錯誤和衝突。集線器有較新的變體，稱為智能集線器。</p>
<p>以太網集線器的三種基本類型如下：</p>
<p>無源集線器–重複信號而不放大<br/>有源集線器–重複放大信號<br/>智能集線器–具有增強功能的活動集線器（例如：SNMP）</p>
<p>集線器內部沒有設計固有的安全性，只是將從一個端口接收的所有信息重新廣播到另一個端口。本質上，集線器僅依賴於連接的工作站來“偵聽”其端口上的信息（如果該信息專門針對該工作站）。當信息沒有發送給它時，工作站應該只是忽略數據。</p>
<p><span style="color: #cc99ff;"><strong>Bridge(橋梁)</strong></span></p>
<p>The hub functions in a single conflict domain to operate together. A network device that can break the conflict domain into smaller units is needed to help the network operate more efficiently. This interconnection of multiple network segments makes the network Can be extended to large networks without significantly reducing the performance of the network. The bridge is smarter than the hub, and is actually analyzing the source, the media access control (MAC) address, and the MAC address for the unique identifier of the network interface for communication. In the frames entering the bridge, the internal MAC table is filled according to these addresses. Future routing decisions will be based on those destination MAC addresses. By only forwarding information to the root hub associated with the network device, this intelligent forwarding based on the target MAC address in the frame can reduce network traffic.</p>
<p>集線器在單個衝突域中起作用的設備一起運行，需要一個可以將該衝突域分解為較小單元的網絡設備，以幫助網絡更高效地運行，多個網段的這種互連在一起使網絡可以擴展到大型網絡，而不會顯著降低該網絡的性能。橋比集線器更智能，實際上是在分析源、媒體訪問控制（MAC）地址MAC地址給網絡接口進行通信的唯一標識符。在進入網橋的幀中，並根據這些地址填充內部MAC表。未來的路由決策將基於那些目標MAC地址。通過僅將信息轉發到與網絡設備關聯的根集線器，這種基於幀中目標MAC地址的智能轉發可減少網絡流量。</p>
<p><span style="color: #cc99ff;"><strong>switch(開關)</strong></span></p>
<p>The switch is used to connect multiple network segments together, and each port on the switch acts as its own conflict domain. Each port on the switch works like a hub, with a bridge that connects the port of the hub to the workstation, thereby reducing the chance of network conflicts to zero.</p>
<p>Switches are smart devices. They make forwarding decisions based on the MAC addresses they learn and place them in their MAC tables. The switch will analyze the source MAC address when it is input, and then fill in the source MAC address in the form of a frame to match the switch port. This allows the switch to forward frames only to the correct device on a single switch port, thereby improving security and network speed.</p>
<p>交換機用於將多個網段連接在一起，交換機上的每個端口都充當其自己的衝突域。交換機上的每個端口都像是集線器一樣工作，帶有將集線器的端口連接到工作站的網橋，從而將網絡衝突的機會降低到零。</p>
<p>交換機是智能設備，它們根據其學習到的MAC地址並將其放置在其MAC表中做出轉發決定。交換機在輸入源MAC地址時會對其進行分析，然後以幀的形式填充源MAC地址，以使其與交換機端口匹配。這允許交換機僅將幀轉發到單個交換機端口上的正確設備，從而提高安全性和網絡速度。</p>
<p><span style="color: #cc99ff;"><strong>router(路由器)</strong></span></p>
<p>The router separates network segments according to IP addresses, and forwards data packets out of the network segment only during configuration. The broadcast domain created by the switch can be decomposed and it is up to network professionals to configure the router to connect different networks together and perform intelligent routing decisions. The router has the closest relationship with the computer because it has a processor and a complex operating system. The router compares the IP addresses of the source and destination of the packet, and forwards traffic to or from the network based on this logical address (for example, IPv4 and IPv6 addresses). Routers are usually feature-rich devices and support multiple interface types, including unshielded twisted pair, optical fiber, and coaxial cable connections. Like a switch, each port on the router is a separate collision domain. Using access control lists, routers can block access to the network based on ports or addresses. This blocking increases the security of the network.</p>
<p>路由器根據IP地址將網段分開，並且僅在配置時將數據包轉發出網段。可以分解由交換機創建的廣播域由網絡專業人員決定將路由器配置為將不同的網絡連接在一起並執行智能路由決策。路由器與計算機的關係最為密切，因為它具有處理器和復雜的操作系統。路由器比較數據包源和目標的IP地址，並基於此邏輯地址（例如，IPv4和IPv6地址）將流量轉發到網絡或從網絡轉發流量。路由器通常是功能豐富的設備，並且支持多種接口類型，包括非屏蔽雙絞線，光纖和同軸電纜連接。像交換機一樣，路由器上的每個端口都是一個單獨的衝突域。使用訪問控制列表，路由器可以根據端口或地址阻止對網絡的訪問。這種阻塞增加了網絡的安全性。</p>
<p><strong><br/><span style="color: #cc99ff;">network adapter(網絡適配器)</span></strong></p>
<p>The network adapter is used to connect the workstation to the network by using media. The network adapter can be built into the motherboard of the device in several ways:</p>
<p>1. Use integrated port clustering.<br/>2. Add to the workstation by using the internal expansion card (PCIe, PCI or mini-PCIe).<br/>3. By using an externally connected card, such as USB or PCMCIA.<br/>4. There are two main types of network adapters: wired and wireless. The cable card supports various cable types.</p>
<p><br/>網絡適配器用於通過使用媒體將工作站連接到網絡。可以通過幾種方式將網絡適配器內置到設備的主板中：</p>
<p>1.使用集成端口集群。<br/>2.通過使用內部擴展卡（PCIe，PCI或mini-PCIe）添加到工作站。<br/>3.通過使用外部連接的卡，例如USB或PCMCIA。<br/>4.網絡適配器有兩種主要類型：有線和無線。有線卡支持各種電纜類型。</p>
<p><span style="color: #cc99ff;"><strong>media(媒體)</strong></span></p>
<p>Media is a term used to classify the physical connection between two device ports. The medium consists of copper cables, optical cables and even radio frequency waves. The cost of the medium varies greatly, from the free cost of radio waves to the cheap price of unshielded twisted pair (copper cable) to the expensive price of fiber optic cables. The type of media determines the bandwidth speed, capacity and distance limits of a particular network.</p>
<p>媒體是用於對兩個設備端口之間的物理連接進行分類的術語。介質由銅纜，光纜甚至射頻波組成。介質的成本差異很大，從無線電波的免費成本到非屏蔽雙絞線（銅纜）的價格便宜，再到光纖電纜的價格昂貴。媒體的類型確定特定網絡的帶寬速度，容量和距離限制。</p>
<h2>Internet media(網路媒體)</h2>
<p><span style="color: #000000;">Optical fiber cables, discuss twisted pair cables and coaxial cables. For each cable type, the appearance, characteristics and types of the connector, as well as speed and limitations.</span></p>
<p>光纖電纜，討論雙絞線電纜和同軸電纜。對於每種電纜類型、連接器的外觀、特性和類型以及速度和限制。</p>
<p><br/><strong><span style="color: #cc99ff;">optic fibre cable(光纖電纜)</span></strong></p>
<p><span style="color: #000000;">Fiber optic cables are constructed by using a glass core in the center of the cable, which is surrounded by a cladding. To send data from one end of the cable to the other, light from a light emitting diode (LED) or laser can be used to transmit the signal down the glass fiber in the center of the cable. Since data is transmitted through light and is not affected by electromagnetic interference (EMI), electromagnetic interference will affect traditional copper-based cables such as twisted pair and coaxial cables. Optical fiber has the ability to transmit data over long distances (many miles) without the use of repeaters. Large bandwidth and information that travels at the speed of light can also carry large amounts of data. Bandwidth can be measured in gigabits or even terabits per second.</span></p>
<p>Multimode fiber optic cable (MMF):</p>
<p>The core wire is larger than a single-mode optical cable. The core size of the multimode fiber is 62.5 microns. Micrometer is a very small unit of measurement, actually even smaller than the width of a human hair. The larger core of the MMF enables multiple propagation modes from one end of the cable to the other. In this way, a single fiber can transmit multiple signals on it, and each signal is transmitted with a slightly different reflection angle. When the light reaches the destination, the signal is then converted back to 1 and 0 and passed to the computer through the network interface card. Multimode optical fiber is usually used in shorter distance optical fiber connections, such as from router to switch, from switch to switch or from server to switch.</p>
<p>Single-mode fiber optic cable (SMF)</p>
<p>: The core wire is much smaller than the multimode optical cable. The core size of SMF is 10 microns. The smaller core of the SMF allows only a single mode of propagation of light from one end of the cable to the other. This through connection allows data to be transmitted over longer distances without a repeater than using MMF. When the light reaches the destination, the signal is then converted back to 1 and 0 and passed to the computer through the network interface card. Single-mode fiber is usually used for ultra-long-distance fiber connections, such as backbone connections from one local area network to another.</p>
<p><span style="color: #cc99ff;"><span style="color: #000000;">光纖電纜是通過在電纜的中心使用玻璃芯構成的，該玻璃芯被包層圍繞。將數據從電纜的一端發送到另一端，可使用來自發光二極管（LED）或激光的光沿電纜中心的玻璃纖維向下傳輸信號。由於數據是通過光傳輸的，不受電磁干擾（EMI）的影響，電磁干擾會影響傳統的銅基電纜，如雙絞線和同軸電纜。光纖具有無需使用中繼器就可以很遠的距離（許多英里）發送數據的能力。大帶寬和以光速傳播的信息，還可以攜帶大量數據。帶寬可以每秒千兆比特或什至兆兆比特來度量。</span><br/></span></p>
<p>多模光纜（MMF）:</p>
<p>芯線比單模光纜大。多模光纖的纖芯尺寸為62.5微米。微米是非常小的度量單位，實際上甚至比人類頭髮的寬度還小。MMF的較大芯線實現了從電纜一端到另一端的多種傳播模式。這樣一來，單根光纖就可以在其上傳輸多個信號，而每個信號都以稍微不同的反射角傳輸。當光線到達目的地時，信號然後被轉換回1和0，並通過網絡接口卡傳遞到計算機。多模光纖通常用於較短距離的光纖連接中，例如從路由器到交換機，從交換機到交換機或從服務器到交換機。</p>
<p>單模光纜（SMF）</p>
<p>:芯線比多模光纜小得多。SMF的芯尺寸為10微米。SMF的較小芯線僅允許光從電纜一端到另一端的單一傳播模式。這種直通連接允許數據在沒有中繼器的情況下傳輸的距離比使用MMF傳輸的距離更長。當光線到達目的地時，信號然後被轉換回1和0，並通過網絡接口卡傳遞到計算機。單模光纖通常用於超長距離的光纖連接中，例如從一個局域網到另一個局域網的骨干連接。</p>
<p><img alt="" height="168" src="/images/下載 (1).jpg" width="299"/></p>
<p><span style="color: #cc99ff;"><strong>Fiber optic cable connector(光纖電纜連接器)</strong></span></p>
<p>Fiber optic cables belong to only the above two types: single-mode and multi-mode. However, there are four types at the end of each cable.</p>
<p>User connector (SC) is a fiber optic cable connector, similar to ordinary audio and video cables, it uses a push-pull mechanism to lock into the port. If you want to enable two-way transmission to send and receive data, you need two fiber optic cables, so dual SC connectors are sometimes used.</p>
<p>Straight (ST) connectors are fiber optic cable connectors that use bayonet plugs and sockets. It is the first de facto standard connector for most commercial wiring using fiber optic cables and is very common in fiber optic networks.</p>
<p>The Lucent connector (LC) is a miniature version of the fiber optic SC connector. It looks a bit like SC, but only half the size, only 1.25mm instead of 2.5mm ferrule, so it is very useful when connecting multiple devices in a small area (such as the front panel of a 24-port switch).</p>
<p>The mechanical transmission registration jack (MT-RJ) connector is a fiber optic cable connector, which is very popular in small devices due to its small size. The connector accommodates two optical fibers and mates with the positioning pins on the plug. These connectors are usually found to connect the switch to the patch panel because the front panels of both devices have a limited area.</p>
<p>光纖電纜僅屬於上述兩種類型：單模和多模。但是，每條電纜的末端都有四種。</p>
<p>用戶連接器（SC）是一種光纖電纜連接器，類似於普通的音頻和視頻電纜，它使用推挽機制鎖入端口。如果要啟用雙向傳輸以發送和接收數據，則需要兩條光纖電纜，因此有時會使用雙SC連接器。</p>
<p>筆直（ST）連接器是使用卡口插頭和插座的光纖電纜連接器。它是大多數使用光纖電纜進行商業佈線的第一個事實上的標準連接器，在光纖網絡中非常常見。</p>
<p>朗訊連接器（LC）是光纖SC連接器的微型版本。它看上去有點像SC，但尺寸只有一半，只有1.25毫米而不是2.5毫米的插芯，因此在小區域（例如24端口交換機的前面板）連接多個設備時非常有用。</p>
<p>機械傳輸註冊插孔（MT-RJ）連接器是一種光纖電纜連接器，由於其尺寸小，在小型設備中非常受歡迎。該連接器容納兩根光纖，並與插頭上的定位銷配對。通常發現這些連接器將開關連接到配線架，因為兩個設備的前面板都有有限的區域。</p>
<p></p>
<h1>HW2</h1>
<h2>2-1</h2>
<p style="text-align: left;"><span style="color: #000080;"><strong>import </strong></span><span style="color: #ff9900;">urllib</span>.request</p>
<p style="text-align: left;"><span style="color: #339966;">導入urllib.request 模塊</span><br/>target_url = "<span style="color: #800080;">https://nfulist.herokuapp.com/?semester=1091&amp;courseno=0776</span>"</p>
<p style="text-align: left;"><span style="color: #339966;">目標網址="https://nfulist.herokuapp.com/?semester=1091&amp;courseno=0776"</span></p>
<p style="text-align: left;">cp1a = []</p>
<p style="text-align: left;"><span style="color: #339966;"> 將網址內容導入[ ]為cp1a函數</span><br/><span style="color: #000080;"><strong>for</strong> </span>line <strong><span style="color: #000080;">in</span> </strong><span style="color: #ff9900;">urllib</span>.request.urlopen(target_url):<br/>   cp1a.append(int(line.decode('<span style="color: #800080;">utf-8</span>').rstrip()))</p>
<p style="text-align: left;"> <span style="color: #339966;">對於urllib.request.urlopen(target_url)內的cp1a.append(int(line.decode('utf-8').rstrip()))</span><br/><span style="color: #000080;"><strong>from</strong> </span><span style="color: #ff9900;">random</span> <strong><span style="color: #000080;">import</span> </strong>shuffle</p>
<p style="text-align: left;"> <span style="color: #339966;">從random模塊中導入shuffle函數</span><br/>shuffle(cp1a)</p>
<p style="text-align: left;"><span style="color: #339966;"> 隨機排列(cp1a)</span><br/>b=[cp1a[i:i +6 ] <span style="color: #000080;"><strong>for</strong> </span>i <span style="color: #000080;"><strong>in</strong> </span>range(<span style="color: #339966;">0</span>, len(cp1a), <span style="color: #339966;">6</span>)]</p>
<p style="text-align: left;"><span style="color: #339966;"> 函數b=[函數cpla[i:i+6]]在i內形成迴圈(0~6的字符串)</span><br/><strong><span style="color: #000080;">print</span></strong>(b)</p>
<p style="text-align: left;"><span style="color: #339966;"> 打印輸出函數b</span></p>
<h2>2-2</h2>
<h2>2-3</h2>
<p></p>
<h1>HW3</h1>
<br/><br/>String Lists  <span>(字串清單)  </span>
<p>strings lists index Exercise 6 (and Solution)</p>
<p><span></span><span>(字符串列表索引)</span><span> </span>(練習6（和解決方案）)</p>
<p><br/>Ask the user for a string and print out whether this string is a palindrome or not. (A palindrome is a string that reads the same forwards and backwards.)<br/>(向用戶詢問一個字符串，然後打印出該字符串是否是回文。（回文是指向前和向後讀取相同字符串的字符串。）)</p>
<p>Discussion(討論區)<br/>Concepts for this week:(本週的概念：)</p>
<p>List indexing(列表索引)<br/>Strings are lists(字符串是列表)<br/>List indexing(列表索引)</p>
<p><br/>In Python (and most programming in general), you start counting lists from the number 0. The first element in a list is “number 0”, the second is “number 1”, etc.<br/>(在Python（以及大多數通用編程）中，您從數字0開始計數列表。列表中的第一個元素是“數字0”，第二個元素是“數字1”，依此類推。)</p>
<p>As a result, when you want to get single elements out of a list, you can ask a list for that number element:<br/>(結果，當您要從列表中刪除單個元素時，可以向列表中請求該number元素：)</p>
<p>&gt;&gt;&gt; a = [5, 10, 15, 20, 25]<br/>&gt;&gt;&gt; a[3]<br/>20<br/>&gt;&gt;&gt; a[0]<br/>5</p>
<p><br/>There is also a convenient way to get sublists between two indices:<br/>(還有一種便捷的方法來獲取兩個索引之間的子列表：)</p>
<p>&gt;&gt;&gt; a = [5, 10, 15, 20, 25, 30, 35, 40]<br/>&gt;&gt;&gt; a[1:4]<br/>[10, 15, 20]<br/>&gt;&gt;&gt; a[6:]<br/>[35, 40]<br/>&gt;&gt;&gt; a[:-1]<br/>[5, 10, 15, 20, 25, 30, 35]</p>
<p><br/>The first number is the “start index” and the last number is the “end index.”<br/>(第一個數字是“開始索引”，最後一個數字是“結束索引”。)</p>
<p>You can also include a third number in the indexing, to count how often you should read from the list:<br/>(您還可以在索引中包含第三個數字，以計算應該從列表中讀取的頻率：)</p>
<p>&gt;&gt;&gt; a = [5, 10, 15, 20, 25, 30, 35, 40]<br/>&gt;&gt;&gt; a[1:5:2]<br/>[10, 20]<br/>&gt;&gt;&gt; a[3:0:-1]<br/>[15, 10, 5]</p>
<p><br/>To read the whole list, just use the variable name (in the above examples, a), or you can also use [:] at the end of the variable name (in the above examples, a[:]).<br/>(要閱讀整個列表，只需使用變量名（在上述示例中，a），或者也可以[:]在變量名的末尾使用（在以上示例中，a[:]）)</p>
<p>Strings are lists(字符串是列表)</p>
<p><br/>Because strings are lists, you can do to strings everything that you do to lists. You can iterate through them:<br/>(因為字符串是列表，所以您可以將對列表所做的所有操作都字符串化。您可以遍歷它們：)</p>
<p>string = "example"<br/>for c in string:<span> </span><br/>print "one letter: " + c<br/>Will give the result:(將給出結果：)</p>
<p>one letter: e<br/>one letter: x<br/>one letter: a<br/>one letter: m<br/>one letter: p<br/>one letter: l<br/>one letter: e</p>
<p><br/>You can take sublists:(您可以列出子列表：)</p>
<p>&gt;&gt;&gt; string = "example"<br/>&gt;&gt;&gt; s = string[0:5]<br/>&gt;&gt;&gt; print s<br/>examp</p>
<p><br/>Now s has the string “examp” in it.<br/>現在，其中s包含字符串“ examp”。</p>
<p>Moral of the story: a string is a list.<br/>(故事的寓意：字符串是一個列表。)</p>
<br/><br/>List Comprehensions (<span>清單理解)</span>
<p>Exercise 7 (and Solution)</p>
<p>清單理解 (練習7（和解決方案）)</p>
<p><br/>Let’s say I give you a list saved in a variable: a = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]. Write one line of Python that takes this list a and makes a new list that has only the even elements of this list in it.<br/>(假設我給您一個保存在變量中的列表：a = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]。編寫一行Python來獲取此列表，a並創建一個僅包含該列表偶數元素的新列表。)</p>
<p>Discussion(討論區)<br/>Concepts for this week:(本週的概念：)</p>
<p>List comprehensions(清單理解)</p>
<p>List comprehensions(清單理解)</p>
<p><br/>The idea of a list comprehension is to make code more compact to accomplish tasks involving lists. Take for example this code:<br/>(列表理解的思想是使代碼更緊湊，以完成涉及列表的任務。以下面的代碼為例：)</p>
<p>years_of_birth = [1990, 1991, 1990, 1990, 1992, 1991]<br/> ages = []<br/> for year in years_of_birth: <br/> ages.append(2014 - year)<br/>And at the end, the variable ages has the list [24, 23, 24, 24, 22, 23]. What this code did was translate the years of birth into ages, and it took us a for loop and an append statement to a new list to do that.<br/>(最後，變量ages具有list [24, 23, 24, 24, 22, 23]。這段代碼所做的就是將出生的歲月轉換成年齡，然後我們使用了for循環，並在新列表中添加了一個append語句來完成此操作。)</p>
<p>Compare to this piece of code:(比較這段代碼：)</p>
<p>years_of_birth = [1990, 1991, 1990, 1990, 1992, 1991]<br/> ages = [2014 - year for year in years_of_birth]<br/>The second line here - the line with ages is a list comprehension.<br/>(這裡的第二行-與的行ages是列表理解。)</p>
<p>It accomplishes the same thing as the first code sample - at the end, the ages variable has a list containing [24, 23, 24, 24, 22, 23], the ages corresponding to all the birthdates.<br/>(它完成了與第一個代碼示例相同的操作-最後，該ages變量具有一個包含的列表[24, 23, 24, 24, 22, 23]，該列表對應於所有生日的年齡。)</p>
<p>The idea of the list comprehension is to condense the for loop and the list appending into one simple line. Notice that the for loop just shifted to the end of the list comprehension, and the part before the for keyword is the thing to append to the end of the new list.<br/>(列表理解的思想是壓縮for循環，並將列表追加到一條簡單的行中。請注意，for循環剛剛移到列表理解的末尾，而for關鍵字之前的部分是要附加到新列表末尾的東西。)</p>
<p>You can also embed if statements into the list comprehension - check out this reference to help you out. There are many examples and a better explanation than I can ever give.<br/>(您還可以將if語句嵌入到列表理解中-請查閱此參考資料以幫助您。有許多例子和比我能提供的更好的解釋。)</p>
<br/><br/>Check Primality Functions (<span>檢查基本功能)</span>
<p>Exercise 11 (and Solution)<br/>檢查基本功能 (練習11（和解決方案）)</p>
<p><br/>Ask the user for a number and determine whether the number is prime or not. (For those who have forgotten, a prime number is a number that has no divisors.). You can (and should!) use your answer to Exercise 4 to help you. Take this opportunity to practice using functions, described below.<br/>(向用戶詢問一個數字，並確定該數字是否為質數。（對於那些忘記的人，質數是沒有除數的數。）您可以（並且應該！）使用練習4的答案來幫助您。藉此機會練習使用如下所述的功能。)</p>
<p>Discussion(討論區)</p>
<p>Concepts for this week:(本週的概念：)</p>
<p>Functions(職能)<br/>Reusable functions(可重用功能)<br/>Default arguments(默認參數)</p>
<p>Functions(職能)<br/>One of the tools programming gives us is the ability to break down problems into easier (or perhaps previously solved) or reusable subproblems. It is good practice to have a function have a single purpose, and the name of that function should hint at it’s purpose in some way.<br/>(編程提供給我們的工具之一是能夠將問題分解為更簡單（或可能先前解決）或可重用的子問題。優良作法是使一個函數具有單一目的，並且該函數的名稱應以某種方式暗示其目的。)</p>
<p>Most programming languages have this idea of a function, subroutine, or subprogram. In Python, a function is a programming construct that allows exactly that.<br/>(大多數編程語言都具有函數，子例程或子程序的概念。在Python中，函數是一種允許這樣做的編程構造。)</p>
<p>Let’s look at a simple example:<br/>(讓我們看一個簡單的例子：)</p>
<p>def get_integer():<br/>return int(input("Give me a number: "))<br/>In this small example, we used the same code that asks a user for input as a tabbed line underneath this def statement. The def means that everything tabbed underneath is a function. The name get_integer() is just a name that I (the programmer) made up. If I just include this code inside a Python file and run it, nothing will happen - all I have done so far is wrapped my code inside of a function; I never told my program to actually RUN my function.<br/>(在這個小示例中，我們使用了相同的代碼來要求用戶輸入此def語句下方的選項卡行。的def手段，一切選項卡式下面是一個函數。這個名字get_integer()只是我（程序員）組成的名字。如果我只是將此代碼包含在Python文件中並運行它，則將不會發生任何事情-到目前為止，我所做的一切都將我的代碼包裝在一個函數中；我從未告訴過我的程序實際運行我的功能。)</p>
<p>def get_integer():<br/>return int(input("Give me a number: "))</p>
<p>age = get_integer()<br/>school_year = get_integer()<br/>if age &gt; 15:<br/>print("You are over the age of 15")<br/>print("You are in grade " + str(school_year))<br/>What I have done here is called the function (told it to run) by writing age = get_integer(). When this line of code runs, what happens is the program will execute (run) the function by asking me for a number, then returning it (giving it back to me) by saving it inside the variable age. Now when I want to ask the user for another number (this time representing the school year), I do the same thing with the variable school_year.<br/>(我在這裡所做的事情通過編寫稱為函數（告訴它運行）age = get_integer()。當這行代碼運行時，程序將通過詢問我一個數字來執行（運行）該函數，然後將其保存在變量中以將其返回（返還給我）age。現在，當我想問用戶另一個數字（這次代表學年）時，我對變量做了同樣的事情school_year。)</p>
<p>Reusable functions(可重用功能)<br/>This is all well and good, but I can make my function do much more for me. Right now, my function will always ask the user for a number by printing the string "Give me a number: ". What if I want to print a different string every time I ask the user for a number, but otherwise use the same idea for the function? In other words, I want a variable parameter in my function that changes every time I call the function based on something I (the programmer) want to be different.<br/>(這一切都很好，但是我可以讓我的功能為我做更多的事情。現在，我的函數將始終通過打印字符串向用戶詢問一個數字"Give me a number: "。如果我想每次問用戶一個數字時都想打印一個不同的字符串，但對於該函數使用相同的想法怎麼辦？換句話說，我希望函數中的變量參數在每次調用函數時都根據我（程序員）希望與眾不同的事物而改變。)</p>
<p>I can do this by passing (giving) my function a variable. Like this:<br/>(我可以通過傳遞（給我的）函數一個變量來做到這一點。像這樣：)</p>
<p>def get_integer(help_text):<br/>return int(input(help_text))</p>
<p>Now what I can do when I call the function is something like this:<br/>現在，當我調用該函數時，我可以做的是這樣的：)</p>
<p>def get_integer(help_text):<br/>return int(input(help_text))</p>
<p>age = get_integer("Tell me your age: ")<br/>school_year = get_integer("What grade are you in? ")<br/>if age &gt; 15:<br/>print("You are over the age of 15")<br/>print("You are in grade " + str(school_year))<br/>Now it is easier for a user to use the program, because the help text is different.<br/>(現在，由於幫助文本不同，因此使用戶更容易使用該程序。)</p>
<p>These variables you pass to functions are called variables, parameters, or arguments.<br/>(傳遞給函數的這些變量稱為變量，參數或參數。)</p>
<p>Default arguments(默認參數)</p>
<p>In the example above, once I have added an argument to my function, I always have to give an argument when I call the function. I can’t forget to give the get_integer() function from above a string to print to the screen. In some cases, I want there to be a “default” behavior for my function that happens when I create an argument for it but don’t give it any.<br/>(在上面的示例中，在向函數添加參數後，在調用函數時始終必須提供參數。我不能忘記get_integer()從字符串上方給函數打印到屏幕上。在某些情況下，我希望函數有一種“默認”行為，這種行為會在為它創建參數但不給出任何參數時發生。)</p>
<p>In the example above, if I don’t give a custom string (which may be 95% of the time I use this function), I just want the input() line to say "Give me a number: " and I want to save myself the trouble of writing this every single time I call the function. So what I can do is give my function default arguments. Like so:<br/>(在上面的示例中，如果我不提供自定義字符串（可能占我使用此函數的時間的95％），我只想讓input()行說出來，"Give me a number: "並且省去了每次編寫此字符串的麻煩我稱這個功能。所以我能做的就是給我的函數默認參數。像這樣：)</p>
<p>def get_integer(help_text="Give me a number: "):<br/>return int(input(help_text))</p>
<p>What happens now is I can use the function in two ways: by giving it an argument and by NOT giving it an argument.<br/>(現在發生的事情是我可以通過兩種方式使用該函數：通過給它一個參數和不給它一個參數。)</p>
<p>def get_integer(help_text="Give me a number: "):<br/>return int(input(help_text))</p>
<p>age = get_integer("Tell me your age: ")<br/>school_year = get_integer()<br/>if age &gt; 15:<br/>print("You are over the age of 15")<br/>print("You are in grade " + str(school_year))<br/>The first time I call the function, it will print "Tell me your age: ", but the second time, it will print "Give me a number: ", because I did not give it a string and it will execute the default behavior.<br/>(第一次調用該函數，它將打印"Tell me your age: "，但是第二次，它將打印"Give me a number: "，因為我沒有給它一個字符串，它將執行默認行為。)</p>
<p>Recap(回顧)<br/>What a function does is wrap a piece of code that we want to reuse, labels it, and allows us to use it again relatively easily. You can add variables to the functions to make your code even MORE reusable, and you can add default arguments to these variables.<br/>(函數的作用是包裝我們要重用的一段代碼，對其進行標記，並允許我們相對容易地再次使用它。您可以將變量添加到函數中，以使代碼更加可重用，並且可以將默認參數添加到這些變量中。)</p>
<p>Functions are a bit strange to deal with at first, but once you master them, they will be your savior in programming. Besides, the whole point of learning programming is abstraction, problem solving, breaking down problems, and that’s exactly what functions are all about.<br/>(一開始處理函數有點奇怪，但是一旦掌握了這些函數，它們就會成為您編程中的救星。此外，學習編程的重點是抽象，解決問題，分解問題，而這正是功能的全部所在。)</p>
<h2>Birthday Months Exercise 35 (and Solution)</h2>
<p><br/>生日月份 (練習35（和解決方案）)</p>
<p>This exercise is Part 3 of 4 of the birthday data exercise series. The other exercises are: Part 1, Part 2, and Part 4.<br/>(此練習是生日數據練習系列4的第3部分。其他練習是：第1部分，第2部分和第4部分。)</p>
<p>In the previous exercise we saved information about famous scientists’ names and birthdays to disk. In this exercise, load that JSON file from disk, extract the months of all the birthdays, and count how many scientists have a birthday in each month.<br/>(在上一個練習中，我們將有關著名科學家的姓名和生日的信息保存到磁盤上。在本練習中，從磁盤加載該JSON文件，提取所有生日的月份，併計算每個月有多少科學家生日。)</p>
<p>Your program should output something like:<br/>(您的程序應輸出如下內容：)</p>
<p>{<br/> "May": 3,<br/> "November": 2,<br/> "December": 1<br/>}<br/>Discussion(討論區)</p>
<p>You already have the skills to achieve this exercise with concepts we’ve already covered: for loops, dictionaries, and basic arithmetic. However, I want to talk about a Python built-in called a Counter.<br/>(您已經具有使用我們已經介紹的概念完成此練習的技能：for循環，字典和基本算術。但是，我想談談稱為的Python內置函數Counter。)</p>
<p>A Counter takes a list and counts how many of each element were in the list. To use the Counter, first import it from collections:<br/>(ACounter獲取一個列表，併計算列表中每個元素的數量。要使用計數器，請先從中導入)</p>
<p>from collections import Counter<br/>This lets you use the Counter data structure built into Python in your program. Then, give it a list:<br/>(這使您可以Counter在程序中使用Python內置的數據結構。然後，給它一個清單：)</p>
<p>sandwiches = ["ham", "cheese", "roast beef", "ham", "cheese", "roast beef", "ham"]<br/>c = Counter(sandwiches)</p>
<p>If you print(c), you will see this:<br/>(如果是print(c)，您將看到以下內容：)</p>
<p>Counter({"ham": 3, "roast beef": 2, "cheese": 2})</p>
<p>This means there are 3 ham, 2 roast beef, and 2 cheese sandwiches in my list. I can get this information directly from the Counter:<br/>(這意味著我的列表中有3個ham，2個roast beef和2個cheese三明治。我可以直接從中獲取此信息Counter：)</p>
<p>&gt;&gt;&gt; print("There are {} ham sandwiches".format(c["ham"]))<br/>There are 3 ham sandwiches</p>
<p>Hope this is useful!(希望這是有用的！)</p>
<p></p>
<h1>進度表</h1>
<ol>
<li><span style="color: #ff00ff;"><strong>完成HW1(10/19)</strong></span></li>
<li><span style="color: #ff00ff;"><strong>建立 ssh-key(11/19)</strong></span></li>
<li><span style="color: #ff00ff;"><strong>重新排版(11/30)</strong></span></li>
<li><span style="color: #ff00ff;"><strong>建立進度表(12/1)</strong><strong></strong><strong></strong></span></li>
<li><span style="color: #ff00ff;"><strong>建立組員名單(12/9)</strong></span></li>
<li><strong><span style="color: #ff00ff;">完成HW2(12/14)-100%</span></strong></li>
<li><strong><span style="color: #ff00ff;">HW3草稿成形(12/20)</span></strong></li>
</ol>
<h1>組員名單</h1>
<p><strong>https://40923252.github.io/cp2020bg4/content/index.html</strong></p>
<p><strong>組長:</strong></p>
<p><strong><span>40923252 魏柏旻</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923252.github.io/cp2020/content/index.html">https://40923252.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><a href="https://github.com/40923252/cp2020">https://github.com/40923252/cp2020</a></span></p>
<p><strong>組員:</strong></p>
<p><strong><span>40723217 林立翔</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40723217.github.io/cp2020/content/index.html">https://40723217.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40723217/cp2020">https://github.com/40723217/cp2020</a></span></span></p>
<p><strong><span>40728238 廖建佑</span></strong><br/><strong>CMSiMDE：</strong><span><a href="https://40728238.github.io/cp2020/content/index.html">https://40728238.github.io/cp2020/content/index.html</a></span><br/><strong>Github：</strong><span><a href="https://github.com/40728238/cp2020">https://github.com/40728238/cp2020</a></span></p>
<p><strong><span>40923206 黃思喬</span></strong><br/><strong>CMSiMDE：</strong><span><a href="https://40923206-1.github.io/cp2020/content/index.html">https://40923206-1.github.io/cp2020/content/index.html</a></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923206-1/cp2020">https://github.com/40923206-1/cp2020</a></span></span></p>
<p><strong><span>40923216 陳彥廷</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923216.github.io/cp2020/content/index.html">https://40923216.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923216/cp2020">https://github.com/40923216/cp2020</a></span></span></p>
<p><strong><span>40923220 陳胡文</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923220.github.io/cp2020/content/index.html">https://40923220.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><a href="https://github.com/40923220/cp2020">https://github.com/40923220/cp2020</a></span></p>
<p><strong><span>40923227 黃宇陽</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923227.github.io/cp2020/content/index.html">https://40923227.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923227/cp2020">https://github.com/40923227/cp2020</a></span></span></p>
<p><strong><span>40923233 楊建霖</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923233.github.io/cp2020/content/index.html">https://40923233.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923233/cp2020">https://github.com/40923233/cp2020</a></span></span></p>
<p><strong><span>40923237 詹明憲</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923237.github.io/cp2020/content/index.html">https://40923237.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923237/cp2020">https://github.com/40923237/cp2020</a></span></span></p>
<p><strong><span>40923243 鄭丞崴</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923243.github.io/cp2020/content/index.html">https://40923243.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923243/cp2020">https://github.com/40923243/cp2020</a></span></span></p>
<p><strong><span>40923253 蘇政嘉</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923253.github.io/cp2020/content/index.html">https://40923253.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923253/cp2020">https://github.com/40923253/cp2020</a></span></span></p>